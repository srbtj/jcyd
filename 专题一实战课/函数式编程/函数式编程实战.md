### 范畴与容器
  1. 把范畴想像成一个容器， 里面包含两个东西: 值 与 值的变形关系(函数);

  2. 范畴伦使用函数， 表达范畴之间的关系。

  3. 本质上，函数式编程只是范畴论的运算方法，跟数学逻辑，微积分等是同一类东西，都是数学方法。  为什么函数式编程是纯的，不能有副作用，因为它是一种数学运算， 原始的目的就是求值， 不做其它事。


### 函子
  函数不仅可以用于同一个范畴之间值的转换，还可以用于将一个范畴转换成另一个范畴。 这种转换需要涉及到函子。

    定义： 函子是函数式编程里面最重要的数据类型， 也是基本的运算单位与功能单位。 首先，函子也是一种范畴，即一个容器，它包含值和变形的关系。 比较特殊的是： 它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。

  #### 代码实现
    概念:
      1）任何拥有map方法的数据结构，都可以做为函子的实现。
      2）遵守一些特定规则的容器
      3）是一个对于函数调用的抽象， 我们赋予容器自己去调用函数的能力。 把一个东西装进一个容器， 只留出一个接口map给容器外的函数。 map一个函数时 我们让容器自己来运行这个函数，这样这个容器就可以自由地选择何时何地如何操作这个函数，以至于拥有惰性求值，错误处理及异步调用等特性。
      实际流程：
        第一把东西装进一个容器 (实际调用 Container.of()方法，实例化一个容器)， 并只留出一个接口map给窗口外的函数，
        第二步：调用map方法，并传入一个函数；
        第三步：map一个函数时，重新返回一个 Container.of()方法，并让新产生的这个容器自己调用传进来的这个函数； 即：
          Container.prototype.map = (f) => {
            return Container.of(f(this._value));
          };

    // 定义一个函子(容器)
    let Container = function (x) {
      this._value = x;
    }
    // 函子拥有一个 of 方法
    Container.of = (x) => new Container(x);
    // 对外提供一个map方法
    Container.prototype.map = function(f) {
      return Constructor.of(f(this._value))
    }


    Container.of(3)
      .map((x) => x + 1)
      .map((x) => 'result' + x);

    es5代码:
      function add (x) {
        return x + 3;
      }
      function result (x) {
        return 'result' + x;
      }

      Container.of(3)
        .map(add)
        .map(result);

      执行过程:
        Container.of(3) ->  new Container(3) -> this._value = 3;
          .map(add) -> return new Container(add(this._value) -> add(3)) -> this._value = add(3) -> 4
          .map(result) -> return new Container(result(this._value) -> result(4)) -> result(4) -> this._value = result(4) ->  result4;

    es6代码:
      class Container {
        constructor (x) {
          this._value = x;
        }
        map (f) {
          return new Container(f(this._value));
        }
      }

      (new Container(3)).map(x => x+1); // 4
